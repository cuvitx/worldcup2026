// ============================================================================
// AI Content Cache — Upstash Redis centralization
// Never generate the same content twice. If ES needs France-Brazil analysis,
// it fetches the JSON generated by Gemini stored in Redis by the FR site.
// ============================================================================

import { Redis } from "@upstash/redis";

/** TTLs in seconds */
export const AI_CACHE_TTL = {
  /** Standard page content (Gemini) — 24h */
  STANDARD_PAGE: 86400,
  /** Expert analysis (Claude Opus) — 12h */
  EXPERT_ANALYSIS: 43200,
  /** Meta descriptions (GPT-5-mini) — 7 days */
  META_DESCRIPTION: 604800,
  /** Translations — 7 days */
  TRANSLATION: 604800,
  /** Live alerts — 5 minutes */
  LIVE_ALERT: 300,
} as const;

// In-memory LRU fallback when Redis is not configured
const memoryCache = new Map<string, { data: string; expiresAt: number }>();
const MAX_CACHE_ENTRIES = 100;

/** Touch a key to mark it as recently used (LRU: move to end of Map) */
function touchLRU(cache: Map<string, { data: string; expiresAt: number }>, key: string) {
  const entry = cache.get(key);
  if (entry) {
    cache.delete(key);
    cache.set(key, entry);
  }
}

/** Evict expired entries, then LRU (oldest first) until under limit */
function evictIfNeeded(cache: Map<string, { data: string; expiresAt: number }>) {
  // Always purge expired entries
  const now = Date.now();
  for (const [key, value] of cache) {
    if (value.expiresAt <= now) {
      cache.delete(key);
    }
  }
  // LRU eviction: delete oldest (first inserted) until under limit
  while (cache.size >= MAX_CACHE_ENTRIES) {
    const firstKey = cache.keys().next().value;
    if (firstKey) cache.delete(firstKey);
    else break;
  }
}

// Lazy-init Redis client
let redis: Redis | null = null;
function getRedis(): Redis | null {
  if (redis) return redis;
  const url = process.env.UPSTASH_REDIS_REST_URL ?? process.env.KV_REST_API_URL;
  const token = process.env.UPSTASH_REDIS_REST_TOKEN ?? process.env.KV_REST_API_TOKEN;
  if (url && token) {
    redis = new Redis({ url, token });
  }
  return redis;
}

/**
 * Get cached AI content. Checks Redis first, then in-memory.
 * Returns null if not found or expired.
 */
export async function aiCacheGet(key: string): Promise<string | null> {
  // Check in-memory first
  const entry = memoryCache.get(key);
  if (entry && entry.expiresAt > Date.now()) {
    touchLRU(memoryCache, key); // Mark as recently used
    return entry.data;
  }
  if (entry) memoryCache.delete(key); // Expired → remove

  // Check Redis
  const kv = getRedis();
  if (kv) {
    try {
      const data = await kv.get<string>(key);
      if (data !== null && data !== undefined) {
        evictIfNeeded(memoryCache);
        memoryCache.set(key, { data, expiresAt: Date.now() + 300_000 });
        return data;
      }
    } catch {
      // Redis unavailable, continue
    }
  }

  return null;
}

/**
 * Store AI content in cache. Writes to Redis and in-memory.
 */
export async function aiCacheSet(
  key: string,
  data: string,
  ttlSeconds: number
): Promise<void> {
  // Always write in-memory
  evictIfNeeded(memoryCache);
  memoryCache.set(key, {
    data,
    expiresAt: Date.now() + ttlSeconds * 1000,
  });

  // Write to Redis if available
  const kv = getRedis();
  if (kv) {
    try {
      await kv.set(key, data, { ex: ttlSeconds });
    } catch {
      // Redis unavailable, in-memory is still set
    }
  }
}

/**
 * Generate a cache key for AI content.
 * Language-agnostic for content that can be shared across sites.
 */
export function aiCacheKey(
  tier: "standard" | "expert" | "infra",
  contentType: string,
  entitySlug: string,
  language?: string
): string {
  const base = `ai:${tier}:${contentType}:${entitySlug}`;
  return language ? `${base}:${language}` : base;
}
