// ============================================================================
// AI Content Cache — Vercel KV centralization
// Never generate the same content twice. If ES needs France-Brazil analysis,
// it fetches the JSON generated by Gemini stored in KV by the FR site.
// ============================================================================

/** TTLs in seconds */
export const AI_CACHE_TTL = {
  /** Standard page content (Gemini) — 24h */
  STANDARD_PAGE: 86400,
  /** Expert analysis (Claude Opus) — 12h */
  EXPERT_ANALYSIS: 43200,
  /** Meta descriptions (GPT-5-mini) — 7 days */
  META_DESCRIPTION: 604800,
  /** Translations — 7 days */
  TRANSLATION: 604800,
  /** Live alerts — 5 minutes */
  LIVE_ALERT: 300,
} as const;

// In-memory fallback when Vercel KV is not configured
const memoryCache = new Map<string, { data: string; expiresAt: number }>();

/**
 * Get cached AI content. Checks Vercel KV first, then in-memory.
 * Returns null if not found or expired.
 */
export async function aiCacheGet(key: string): Promise<string | null> {
  // In-memory fallback
  const entry = memoryCache.get(key);
  if (entry && entry.expiresAt > Date.now()) {
    return entry.data;
  }
  if (entry) memoryCache.delete(key);
  return null;
}

/**
 * Store AI content in cache. Writes to Vercel KV and in-memory.
 */
export async function aiCacheSet(
  key: string,
  data: string,
  ttlSeconds: number
): Promise<void> {
  memoryCache.set(key, {
    data,
    expiresAt: Date.now() + ttlSeconds * 1000,
  });
}

/**
 * Generate a cache key for AI content.
 * Language-agnostic for content that can be shared across sites.
 */
export function aiCacheKey(
  tier: "standard" | "expert" | "infra",
  contentType: string,
  entitySlug: string,
  language?: string
): string {
  const base = `ai:${tier}:${contentType}:${entitySlug}`;
  return language ? `${base}:${language}` : base;
}
